{"ast":null,"code":"import axios from \"axios\";\nimport { broadcastAuthChange, clearToken, isTokenExpired, markSessionActive, persistToken, readToken, shouldProactivelyRefresh } from \"../utils/authSignal\";\nimport { ensureFreshAccessToken, setSessionExpiredFlag } from \"../utils/sessionManager\";\n\n// Create axios instance that points to the backend proxy (CRA will proxy /api to backend)\nconst api = axios.create({\n  baseURL: \"/\",\n  withCredentials: true\n});\n\n// Attach Authorization token from session storage if present\napi.interceptors.request.use(async config => {\n  let token = readToken();\n  if (token && (shouldProactivelyRefresh() || isTokenExpired())) {\n    try {\n      token = await ensureFreshAccessToken();\n    } catch (error) {\n      token = readToken();\n    }\n  }\n  if (token) {\n    config.headers = config.headers || {};\n    config.headers.Authorization = `Bearer ${token}`;\n    markSessionActive();\n  }\n\n  // For mutating requests, ensure we have X-CSRF-Token set. We store token on first fetch.\n  const method = (config.method || \"get\").toLowerCase();\n  if ([\"post\", \"put\", \"patch\", \"delete\"].includes(method)) {\n    if (!api.defaults.headers[\"X-CSRF-Token\"]) {\n      try {\n        // include credentials so cookie-based token is set by server\n        const res = await axios.get(\"/api/csrf-token\", {\n          withCredentials: true\n        });\n        api.defaults.headers[\"X-CSRF-Token\"] = res.data.csrfToken;\n      } catch (e) {\n        // ignore — server may be configured to not require CSRF in dev\n      }\n    }\n    config.headers = config.headers || {};\n    if (api.defaults.headers[\"X-CSRF-Token\"] && !config.headers[\"X-CSRF-Token\"]) {\n      config.headers[\"X-CSRF-Token\"] = api.defaults.headers[\"X-CSRF-Token\"];\n    }\n  }\n  return config;\n});\n\n// Response interceptor: if 401/403 attempt to refresh token once and retry\nlet isRefreshing = false;\nconst refreshSubscribers = [];\nconst shouldBypassRefresh = request => {\n  if (!request || !request.url) return false;\n  const url = request.url.toString();\n  return [\"/api/auth/login\", \"/api/auth/login/mfa\", \"/api/auth/register\", \"/api/auth/refresh-token\"].some(path => url.includes(path));\n};\nfunction onRefreshed(newToken) {\n  refreshSubscribers.forEach(cb => cb(newToken));\n  refreshSubscribers.length = 0;\n}\nfunction addRefreshSubscriber(cb) {\n  refreshSubscribers.push(cb);\n}\napi.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n  if (originalRequest && !originalRequest._retry && error.response && (error.response.status === 401 || error.response.status === 403)) {\n    if (shouldBypassRefresh(originalRequest)) {\n      return Promise.reject(error);\n    }\n    originalRequest._retry = true;\n    try {\n      if (!isRefreshing) {\n        isRefreshing = true;\n        // Attempt refresh using refresh-token cookie\n        const res = await axios.post(\"/api/auth/refresh-token\", {}, {\n          withCredentials: true\n        });\n        const newToken = res.data.accessToken;\n        if (newToken) {\n          persistToken(newToken);\n          broadcastAuthChange();\n          onRefreshed(newToken);\n        }\n        isRefreshing = false;\n      }\n      return new Promise((resolve, reject) => {\n        addRefreshSubscriber(newToken => {\n          // update the original request Authorization header and retry\n          originalRequest.headers = originalRequest.headers || {};\n          if (newToken) originalRequest.headers.Authorization = `Bearer ${newToken}`;\n          resolve(api(originalRequest));\n        });\n      });\n    } catch (e) {\n      // refresh failed — clear token and propagate error\n      clearToken();\n      setSessionExpiredFlag();\n      broadcastAuthChange();\n      return Promise.reject(error);\n    }\n  }\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","broadcastAuthChange","clearToken","isTokenExpired","markSessionActive","persistToken","readToken","shouldProactivelyRefresh","ensureFreshAccessToken","setSessionExpiredFlag","api","create","baseURL","withCredentials","interceptors","request","use","config","token","error","headers","Authorization","method","toLowerCase","includes","defaults","res","get","data","csrfToken","e","isRefreshing","refreshSubscribers","shouldBypassRefresh","url","toString","some","path","onRefreshed","newToken","forEach","cb","length","addRefreshSubscriber","push","response","originalRequest","_retry","status","Promise","reject","post","accessToken","resolve"],"sources":["D:/BMUDHT/frontend/src/services/api.js"],"sourcesContent":["import axios from \"axios\";\r\nimport {\r\n  broadcastAuthChange,\r\n  clearToken,\r\n  isTokenExpired,\r\n  markSessionActive,\r\n  persistToken,\r\n  readToken,\r\n  shouldProactivelyRefresh,\r\n} from \"../utils/authSignal\";\r\nimport {\r\n  ensureFreshAccessToken,\r\n  setSessionExpiredFlag,\r\n} from \"../utils/sessionManager\";\r\n\r\n// Create axios instance that points to the backend proxy (CRA will proxy /api to backend)\r\nconst api = axios.create({\r\n  baseURL: \"/\",\r\n  withCredentials: true,\r\n});\r\n\r\n// Attach Authorization token from session storage if present\r\napi.interceptors.request.use(async (config) => {\r\n  let token = readToken();\r\n\r\n  if (token && (shouldProactivelyRefresh() || isTokenExpired())) {\r\n    try {\r\n      token = await ensureFreshAccessToken();\r\n    } catch (error) {\r\n      token = readToken();\r\n    }\r\n  }\r\n\r\n  if (token) {\r\n    config.headers = config.headers || {};\r\n    config.headers.Authorization = `Bearer ${token}`;\r\n    markSessionActive();\r\n  }\r\n\r\n  // For mutating requests, ensure we have X-CSRF-Token set. We store token on first fetch.\r\n  const method = (config.method || \"get\").toLowerCase();\r\n  if ([\"post\", \"put\", \"patch\", \"delete\"].includes(method)) {\r\n    if (!api.defaults.headers[\"X-CSRF-Token\"]) {\r\n      try {\r\n        // include credentials so cookie-based token is set by server\r\n        const res = await axios.get(\"/api/csrf-token\", {\r\n          withCredentials: true,\r\n        });\r\n        api.defaults.headers[\"X-CSRF-Token\"] = res.data.csrfToken;\r\n      } catch (e) {\r\n        // ignore — server may be configured to not require CSRF in dev\r\n      }\r\n    }\r\n    config.headers = config.headers || {};\r\n    if (\r\n      api.defaults.headers[\"X-CSRF-Token\"] &&\r\n      !config.headers[\"X-CSRF-Token\"]\r\n    ) {\r\n      config.headers[\"X-CSRF-Token\"] = api.defaults.headers[\"X-CSRF-Token\"];\r\n    }\r\n  }\r\n\r\n  return config;\r\n});\r\n\r\n// Response interceptor: if 401/403 attempt to refresh token once and retry\r\nlet isRefreshing = false;\r\nconst refreshSubscribers = [];\r\n\r\nconst shouldBypassRefresh = (request) => {\r\n  if (!request || !request.url) return false;\r\n  const url = request.url.toString();\r\n  return [\r\n    \"/api/auth/login\",\r\n    \"/api/auth/login/mfa\",\r\n    \"/api/auth/register\",\r\n    \"/api/auth/refresh-token\",\r\n  ].some((path) => url.includes(path));\r\n};\r\n\r\nfunction onRefreshed(newToken) {\r\n  refreshSubscribers.forEach((cb) => cb(newToken));\r\n  refreshSubscribers.length = 0;\r\n}\r\n\r\nfunction addRefreshSubscriber(cb) {\r\n  refreshSubscribers.push(cb);\r\n}\r\n\r\napi.interceptors.response.use(\r\n  (response) => response,\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    if (\r\n      originalRequest &&\r\n      !originalRequest._retry &&\r\n      error.response &&\r\n      (error.response.status === 401 || error.response.status === 403)\r\n    ) {\r\n      if (shouldBypassRefresh(originalRequest)) {\r\n        return Promise.reject(error);\r\n      }\r\n      originalRequest._retry = true;\r\n      try {\r\n        if (!isRefreshing) {\r\n          isRefreshing = true;\r\n          // Attempt refresh using refresh-token cookie\r\n          const res = await axios.post(\r\n            \"/api/auth/refresh-token\",\r\n            {},\r\n            { withCredentials: true }\r\n          );\r\n          const newToken = res.data.accessToken;\r\n          if (newToken) {\r\n            persistToken(newToken);\r\n            broadcastAuthChange();\r\n            onRefreshed(newToken);\r\n          }\r\n          isRefreshing = false;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n          addRefreshSubscriber((newToken) => {\r\n            // update the original request Authorization header and retry\r\n            originalRequest.headers = originalRequest.headers || {};\r\n            if (newToken)\r\n              originalRequest.headers.Authorization = `Bearer ${newToken}`;\r\n            resolve(api(originalRequest));\r\n          });\r\n        });\r\n      } catch (e) {\r\n        // refresh failed — clear token and propagate error\r\n        clearToken();\r\n        setSessionExpiredFlag();\r\n        broadcastAuthChange();\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}