{"ast":null,"code":"import axios from\"axios\";// Create axios instance that points to the backend proxy (CRA will proxy /api to backend)\nconst api=axios.create({baseURL:\"/\",withCredentials:true});// Attach Authorization token from localStorage if present\napi.interceptors.request.use(async config=>{const token=localStorage.getItem(\"token\");if(token){config.headers=config.headers||{};config.headers.Authorization=\"Bearer \".concat(token);}// For mutating requests, ensure we have X-CSRF-Token set. We store token on first fetch.\nconst method=(config.method||\"get\").toLowerCase();if([\"post\",\"put\",\"patch\",\"delete\"].includes(method)){if(!api.defaults.headers[\"X-CSRF-Token\"]){try{// include credentials so cookie-based token is set by server\nconst res=await axios.get(\"/api/csrf-token\",{withCredentials:true});api.defaults.headers[\"X-CSRF-Token\"]=res.data.csrfToken;}catch(e){// ignore — server may be configured to not require CSRF in dev\n}}config.headers=config.headers||{};if(api.defaults.headers[\"X-CSRF-Token\"]&&!config.headers[\"X-CSRF-Token\"]){config.headers[\"X-CSRF-Token\"]=api.defaults.headers[\"X-CSRF-Token\"];}}return config;});// Response interceptor: if 401/403 attempt to refresh token once and retry\nlet isRefreshing=false;const refreshSubscribers=[];function onRefreshed(newToken){refreshSubscribers.forEach(cb=>cb(newToken));refreshSubscribers.length=0;}function addRefreshSubscriber(cb){refreshSubscribers.push(cb);}api.interceptors.response.use(response=>response,async error=>{const originalRequest=error.config;if(originalRequest&&!originalRequest._retry&&error.response&&(error.response.status===401||error.response.status===403)){originalRequest._retry=true;try{if(!isRefreshing){isRefreshing=true;// Attempt refresh using refresh-token cookie\nconst res=await axios.post(\"/api/auth/refresh-token\",{},{withCredentials:true});const newToken=res.data.accessToken;if(newToken){localStorage.setItem(\"token\",newToken);onRefreshed(newToken);}isRefreshing=false;}return new Promise((resolve,reject)=>{addRefreshSubscriber(newToken=>{// update the original request Authorization header and retry\noriginalRequest.headers=originalRequest.headers||{};if(newToken)originalRequest.headers.Authorization=\"Bearer \".concat(newToken);resolve(api(originalRequest));});});}catch(e){// refresh failed — clear token and propagate error\nlocalStorage.removeItem(\"token\");return Promise.reject(error);}}return Promise.reject(error);});export default api;","map":{"version":3,"names":["axios","api","create","baseURL","withCredentials","interceptors","request","use","config","token","localStorage","getItem","headers","Authorization","concat","method","toLowerCase","includes","defaults","res","get","data","csrfToken","e","isRefreshing","refreshSubscribers","onRefreshed","newToken","forEach","cb","length","addRefreshSubscriber","push","response","error","originalRequest","_retry","status","post","accessToken","setItem","Promise","resolve","reject","removeItem"],"sources":["D:/BMUDHT/frontend/src/services/api.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// Create axios instance that points to the backend proxy (CRA will proxy /api to backend)\r\nconst api = axios.create({\r\n  baseURL: \"/\",\r\n  withCredentials: true,\r\n});\r\n\r\n// Attach Authorization token from localStorage if present\r\napi.interceptors.request.use(async (config) => {\r\n  const token = localStorage.getItem(\"token\");\r\n  if (token) {\r\n    config.headers = config.headers || {};\r\n    config.headers.Authorization = `Bearer ${token}`;\r\n  }\r\n\r\n  // For mutating requests, ensure we have X-CSRF-Token set. We store token on first fetch.\r\n  const method = (config.method || \"get\").toLowerCase();\r\n  if ([\"post\", \"put\", \"patch\", \"delete\"].includes(method)) {\r\n    if (!api.defaults.headers[\"X-CSRF-Token\"]) {\r\n      try {\r\n        // include credentials so cookie-based token is set by server\r\n        const res = await axios.get(\"/api/csrf-token\", {\r\n          withCredentials: true,\r\n        });\r\n        api.defaults.headers[\"X-CSRF-Token\"] = res.data.csrfToken;\r\n      } catch (e) {\r\n        // ignore — server may be configured to not require CSRF in dev\r\n      }\r\n    }\r\n    config.headers = config.headers || {};\r\n    if (\r\n      api.defaults.headers[\"X-CSRF-Token\"] &&\r\n      !config.headers[\"X-CSRF-Token\"]\r\n    ) {\r\n      config.headers[\"X-CSRF-Token\"] = api.defaults.headers[\"X-CSRF-Token\"];\r\n    }\r\n  }\r\n\r\n  return config;\r\n});\r\n\r\n// Response interceptor: if 401/403 attempt to refresh token once and retry\r\nlet isRefreshing = false;\r\nconst refreshSubscribers = [];\r\n\r\nfunction onRefreshed(newToken) {\r\n  refreshSubscribers.forEach((cb) => cb(newToken));\r\n  refreshSubscribers.length = 0;\r\n}\r\n\r\nfunction addRefreshSubscriber(cb) {\r\n  refreshSubscribers.push(cb);\r\n}\r\n\r\napi.interceptors.response.use(\r\n  (response) => response,\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    if (\r\n      originalRequest &&\r\n      !originalRequest._retry &&\r\n      error.response &&\r\n      (error.response.status === 401 || error.response.status === 403)\r\n    ) {\r\n      originalRequest._retry = true;\r\n      try {\r\n        if (!isRefreshing) {\r\n          isRefreshing = true;\r\n          // Attempt refresh using refresh-token cookie\r\n          const res = await axios.post(\r\n            \"/api/auth/refresh-token\",\r\n            {},\r\n            { withCredentials: true }\r\n          );\r\n          const newToken = res.data.accessToken;\r\n          if (newToken) {\r\n            localStorage.setItem(\"token\", newToken);\r\n            onRefreshed(newToken);\r\n          }\r\n          isRefreshing = false;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n          addRefreshSubscriber((newToken) => {\r\n            // update the original request Authorization header and retry\r\n            originalRequest.headers = originalRequest.headers || {};\r\n            if (newToken)\r\n              originalRequest.headers.Authorization = `Bearer ${newToken}`;\r\n            resolve(api(originalRequest));\r\n          });\r\n        });\r\n      } catch (e) {\r\n        // refresh failed — clear token and propagate error\r\n        localStorage.removeItem(\"token\");\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}